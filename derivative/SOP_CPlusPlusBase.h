/* Shared Use License: This file is owned by Derivative Inc. (Derivative) and
* can only be used, and/or modified for use, in conjunction with
* Derivative's TouchDesigner software, and only if you are a licensee who has
* accepted Derivative's TouchDesigner license or assignment agreement (which
* also govern the use of this file).  You may share a modified version of this
* file with another authorized licensee of Derivative's TouchDesigner software.
* Otherwise, no redistribution or sharing of this file, with or without
* modification, is permitted.
*/

/*
* Produced by:
*
* 				Derivative Inc
*				401 Richmond Street West, Unit 386
*				Toronto, Ontario
*				Canada   M5V 3A8
*				416-591-3555
*
* NAME:				SOP_CPlusPlusBase.h
*
*
*	Do not edit this file directly!
*	Make a subclass of SOP_CPlusPlusBase instead, and add your own
*	data/functions.

*	Derivative Developers:: Make sure the virtual function order
*	stays the same, otherwise changes won't be backwards compatible
*/
//#pragma once

#ifndef __SOP_CPlusPlusBase__
#define __SOP_CPlusPlusBase__

#include "CPlusPlus_Common.h"

#define SOP_CPLUSPLUS_API_VERSION	1

class SOP_CPlusPlusBase;


// These are the definitions for the C-functions that are used to
// load the library and create instances of the object you define
typedef int32_t(__cdecl *GETSOPAPIVERSION)(void);
typedef SOP_CPlusPlusBase* (__cdecl *CREATESOPINSTANCE)(const OP_NodeInfo*);
typedef void(__cdecl *DESTROYSOPINSTANCE)(SOP_CPlusPlusBase*);


class SOP_GeneralInfo
{
public:
	// Set this to true if you want the SOP to cook every frame, even
	// if none of it's inputs/parameters are changing, and nobody is asking
	// for it's output (asking for it to cook).
	// Defaults to false.
	bool	cookEveryFrame;

	// Set this to true if you want the SOP to cook every frame, but only
	// if someone asks for it to cook. So if nobody is using the output from
	// the SOP, it won't cook. This is difereent from 'cookEveryFrame'
	// since that will cause it to cook every frame no matter what.
	// Defaults to false.
	bool	cookEveryFrameIfAsked;


	// Set this flag to true to load the geometry to the GPU for faster updating
	// Note that if you set this flag to 'true', then the function executeVBO() is being called
	// instead of execute() function. 
	// If this flag is set to false, then execute() function is called.
	// When directToGPU is true, the data is not available to be used in SOPs,
	// except to be rendered with a Render TOP.
	// Defaults to false.
	bool	directToGPU;


private:

	int32_t	reserved[20];
};



// The buffer object mode. 
// This helps the graphics driver determine where to keep the data
// for beter performance.
enum  class VBOBufferMode : int32_t
{
	// The data will be modified once or rarely and used many times.
	Static = 0,  

	// The data will be modified repeatedly and used many times.
	Dynamic,
};


// This class is used to create geometry on the CPU, to be used in SOP networks.
// NOTE: set 'directToGPU' flag from SOP_GeneralInfo class to false.
class SOP_Output
{
public:

	SOP_Output()
	{
	}

	~SOP_Output()
	{
	}


	// Add multiple points at specified positions.
	// The 'positions' array holds the of x, y, and z of input points.
	// 'numPoints' is the number of points to be added. 
	// 'positions' must have at least 3 * numPoints elements.
	virtual void	addPoints(const float *positions, int32_t numPoints) = 0;

	// Add a single point at the given position.
	// Returns the point's index.
	virtual int32_t	addPoint(float x, float y, float z) = 0;

	// Set the normal vector for the point with the 'pointIdx'.
	// The point must already exist by via calling addPoints() or addPoint().
	virtual void	setNormal(float x, float y, float z, int32_t pointIdx) = 0;

	// Set the normal vectors for existing points.
	// Note that has been the points must be already added by calling addPoints() or addPoint().
	// 'normals' must be an array of XYZ values, with size at least 3*numPoints.
	// The startPointIdx indicates the start index of the points to set normals for.
	virtual bool	setNormals(const float *normals, int32_t numPoints, int32_t startPointIdx) = 0;

	// Set the color value with r,g,b,a for the point with 'pointIdx' index.
	// The point must already exist by via calling addPoints() or addPoint().
	virtual void	setColor(float r, float g, float b, float a, int32_t pointIdx) = 0;

	// Set the colors for points that are already added.
	// 'colors' must be an array of RGBA values, with size at least 4*numPoints.
	// The startPointIdx indicates the start index of the points to set colors for.
	virtual bool	setColors(const float *colors, int32_t numPoints, int32_t startPointIdx) = 0;


	// Set the custom attribute with it's name, number of components, and it's type
	// The data param must hold the data for the custom attribute.
	// E.g a custom atrrib with 4 components for each point should holds 4*numPoints values.
	virtual void	setCustomAttribute(const char *name, int32_t numComp, AttribType type, const void *data, int32_t numPoints) = 0;

	// Set texture coordinate data for existing points.
	// tex should be an array of UVW values, with size at least 3*numPoints.
	// the texSize is the texture size and can be from 1 up to 8 for texture layers
	// the pointIdx specifies the point index with the texture coords
	virtual void	setTexture(const float *tex, int32_t texSize, int32_t pointIdx) = 0;

	// Add a triangle using the points at the given 3 indices.
	virtual void	addTriangle(int32_t ptIdx1, int32_t ptIdx2, int32_t ptIdx3) = 0;

	// Add multiple triangles using an array of point's indices.
	// The size param represents the number of triangles to be added.
	// 'indices' must contain at least 3 * size elements.
	virtual bool	addTriangles(const int32_t *indices, int32_t size) = 0;

	// add particle systems from the points that has been already added. The points can have colors, normals and custom attribs.
	// the startIndex param is the staring index of the points from particle system.

	virtual void	addParticleSystem(int32_t numParticles, int32_t startIndex) = 0;


private:

	int32_t    reserved[20];
};


// This class is used to load geometry directly onto the GPU. The geometry can be used for rendering, but not SOP networks.
// NOTE: set 'directToGPU' flag from SOP_GeneralInfo class to true.
class SOP_VBOOutput
{

public:

	SOP_VBOOutput()
	{
	}


	~SOP_VBOOutput()
	{
	}

	// enable/set the normal and color if the geometry contains this information
	virtual void	enableNormal() = 0;

	virtual void	enableColor() = 0;

	virtual bool	hasNormal() = 0;

	virtual bool	hasColor() = 0;

	// Add the custom attribute with it's name, number of components, and it's type.
	virtual void	addCustomAttribute(const char *name, int32_t numComp, AttribType type) = 0;

	// Allocates and setup VBO buffers. 
	// Call this fucntion before adding any points, colors or normals,
	// but after enableNormal(), enableColor(), addCustomAttribute().
	// 'numVertices' is how much memory to allocate for positions/normals etc.
	// 'numIndices' is how much memory to allocate for indices that are used
	// to build primitives.
	virtual void	allocVBO(int32_t numVertices, int32_t numIndices, VBOBufferMode mode) = 0;

	// Returns the start of the array for the vertex positions.
	// The length of this array is numVertices * 3
	virtual float*	getPos() = 0;

	// Returns the start of the array for the vertex normals.
	// The length of this area is numVertices * 3
	virtual float*	getNormals() = 0;

	// Returns the start of the array for the vertex colors.
	// The length of this array is numVertices * 4
	virtual float*	getColors() = 0;

	// Create 'numTriangles' triangles. 
	// Returns the indices for the vertices of these triangles. The indices
	// for all the triangles must be set, their initial values is undefined.
	// Length of the returned array is numTriangles * 3.
	virtual int32_t*	getTriangles(int32_t numTriangles) = 0;

	// Returns the start of the array for the custom attributes by its name.
	virtual float*	getCustomAttribute(const char *name) = 0;

	// Finish updating the VBO buffers.
	// After you are done with the VBO buffers, make sure to call this function
	// Note: this function must be the last function to be called 
	virtual void	updateComplete() = 0;


private:

};



/*** DO NOT EDIT THIS CLASS, MAKE A SUBCLASS OF IT INSTEAD ***/
class SOP_CPlusPlusBase
{

protected:

	SOP_CPlusPlusBase()
	{
	}

public:

	virtual
	~SOP_CPlusPlusBase()
	{
	}

	// BEGIN PUBLIC INTERFACE

	// Some general settings can be assigned here (if you ovierride it)
	virtual void
	getGeneralInfo(SOP_GeneralInfo*)
	{
	}


	// Add geometry data such as points, normals, colors, and triangles
	// or particles and etc. obtained from your desired algorithm or external files.
	// If the "directToGPU" flag is set to false, this function is being called
	// instead of executeVBO().
	// See the OP_Inputs class definition for more details on it's contents
	virtual void	execute(SOP_Output*, OP_Inputs*, void* reserved) = 0;

	// For direct GPU loading (i.e "directToGPU" is set to true) this function is being called
	// instead of execute().
	// Fill the VBO buffers with the geometry data, obtained from your desired algorithm or files,
	// such as points, normals, colors, textures, triangles, and etc.
	virtual void	executeVBO(SOP_VBOOutput*, OP_Inputs*, void* reserved) = 0;


	// Override these methods if you want to output values to the Info CHOP/DAT
	// returning 0 means you dont plan to output any Info CHOP channels
	virtual int32_t
	getNumInfoCHOPChans()
	{
		return 0;
	}

	// Specify the name and value for CHOP 'index',
	// by assigning something to 'name' and 'value' members of the
	// OP_InfoCHOPChan class pointer that is passed (it points
	// to a valid instance of the class already.
	// the 'name' pointer will initially point to nullptr
	// you must allocate memory or assign a constant string
	// to it.
	virtual void
	getInfoCHOPChan(int32_t index,OP_InfoCHOPChan* chan)
	{
	}


	// Return false if you arn't returning data for an Info DAT
	// Return true if you are.
	// Set the members of the CHOP_InfoDATSize class to specify
	// the dimensions of the Info DAT
	virtual bool
	getInfoDATSize(OP_InfoDATSize* infoSize)
	{
		return false;
	}


	// You are asked to assign values to the Info DAT 1 row or column at a time
	// The 'byColumn' variable in 'getInfoDATSize' is how you specify
	// if it is by column or by row.
	// 'index' is the row/column index
	// 'nEntries' is the number of entries in the row/column
	virtual void
	getInfoDATEntries(int32_t index, int32_t nEntries, OP_InfoDATEntries* entries)
	{
	}


	// You can use this function to put the node into a warning state
	// with the returned string as the message.
	// Return nullptr if you don't want it to be in a warning state.
	virtual const char*
	getWarningString()
	{
		return nullptr;
	}

	// You can use this function to put the node into a error state
	// with the returned string as the message.
	// Return nullptr if you don't want it to be in a error state.
	virtual const char*
	getErrorString()
	{
		return nullptr;
	}

	// Use this function to return some text that will show up in the
	// info popup (when you middle click on a node)
	// Return nullptr if you don't want to return anything.
	virtual const char*
	getInfoPopupString()
	{
		return nullptr;
	}


	// Override these methods if you want to define specfic parameters
	virtual void
	setupParameters(OP_ParameterManager* manager)
	{
	}


	// This is called whenever a pulse parameter is pressed
	virtual void
	pulsePressed(const char* name)
	{
	}

	// END PUBLIC INTERFACE


private:

	// Reserved for future features
	virtual int32_t	reservedFunc6() { return 0; }
	virtual int32_t	reservedFunc7() { return 0; }
	virtual int32_t	reservedFunc8() { return 0; }
	virtual int32_t	reservedFunc9() { return 0; }
	virtual int32_t	reservedFunc10() { return 0; }
	virtual int32_t	reservedFunc11() { return 0; }
	virtual int32_t	reservedFunc12() { return 0; }
	virtual int32_t	reservedFunc13() { return 0; }
	virtual int32_t	reservedFunc14() { return 0; }
	virtual int32_t	reservedFunc15() { return 0; }
	virtual int32_t	reservedFunc16() { return 0; }
	virtual int32_t	reservedFunc17() { return 0; }
	virtual int32_t	reservedFunc18() { return 0; }
	virtual int32_t	reservedFunc19() { return 0; }
	virtual int32_t	reservedFunc20() { return 0; }

	int32_t			reserved[400];

};

#endif
